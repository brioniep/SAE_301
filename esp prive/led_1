#include <ESP8266WiFi.h>          // Bibliothèque pour gérer le WiFi sur l'ESP8266
#include <PubSubClient.h>         // Bibliothèque pour le client MQTT
#include <WiFiManager.h>          // Bibliothèque pour la gestion automatique du WiFi
#include <OneWire.h>              // Bibliothèque pour le protocole OneWire
#include <DallasTemperature.h>    // Bibliothèque pour les capteurs de température Dallas

// Adresse du serveur MQTT (broker)
const char* mqtt_server = "your_private_broker_address";
const char* mqtt_user = "your_username";       // Nom d'utilisateur pour le broker MQTT
const char* mqtt_password = "your_password";   // Mot de passe pour le broker MQTT

// Déclaration des objets WiFi et MQTT
WiFiClient espClient;
PubSubClient client(espClient);

// Variables pour la gestion des messages MQTT
unsigned long lastMsg = 0;
#define MSG_BUFFER_SIZE (50)
char msg[MSG_BUFFER_SIZE];

// Configuration du bouton et de l'état LED
#define BUTTON_PIN 14  // Pin D1 pour le bouton
int button_state = 0;         // État du bouton
int last_button_state = HIGH; // Dernier état connu du bouton
bool led_state = false;       // État actuel de la LED

// Configuration du capteur de température
#define ONE_WIRE_BUS 13       // Le fil de données est connecté à GPIO13
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

// Fonction de connexion WiFi via WiFiManager
void setup_wifi() {
  WiFiManager wifiManager;
  wifiManager.autoConnect("ESP8266_AP");  // Crée un AP pour la configuration
  Serial.println("Connecté au WiFi");
}

// Callback pour gérer les messages MQTT entrants
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message reçu [");
  Serial.print(topic);
  Serial.print("] ");

  String messageTemp;
  for (int i = 0; i < length; i++) {
    messageTemp += (char)payload[i];  // Convertit la charge utile en string
  }
  Serial.println(messageTemp);

  // Vérifie si le message concerne le contrôle de la LED
  if (String(topic) == "IUT/on/off/led_1") {
    if (messageTemp == "led_1_on") {
      digitalWrite(BUILTIN_LED, LOW); // Allume la LED
      led_state = true;
      Serial.println("LED ON");
    } else if (messageTemp == "led_1_off") {
      digitalWrite(BUILTIN_LED, HIGH); // Éteint la LED
      led_state = false;
      Serial.println("LED OFF");
    }
  }
}

// Fonction pour reconnecter le client MQTT si la connexion est perdue
void reconnect() {
  while (!client.connected()) {
    Serial.print("Connexion au serveur MQTT...");
    String clientId = "ESP8266Client-";
    clientId += String(random(0xffff), HEX);  // Génère un ID client unique
    if (client.connect(clientId.c_str(), mqtt_user, mqtt_password)) {
      Serial.println("connecté");
      client.subscribe("IUT/on/off/led_1");         // Abonne au sujet pour contrôler la LED
      client.subscribe("IUT/etat/led_1");
      client.subscribe("IUT/temperature");   // Abonne au sujet pour les températures
    } else {
      Serial.print("échec, rc=");
      Serial.print(client.state());
      Serial.println(" nouvelle tentative dans 5 secondes");
      delay(5000);  // Attend 5 secondes avant de réessayer
    }
  }
}

void setup() {
  pinMode(BUILTIN_LED, OUTPUT);           // Définit la LED comme sortie
  digitalWrite(BUILTIN_LED, HIGH);        // LED éteinte par défaut (active LOW)
  Serial.begin(115200);                   // Démarre la communication série
  setup_wifi();                           // Connexion au WiFi
  client.setServer(mqtt_server, 1883);    // Configure le serveur MQTT
  client.setCallback(callback);           // Définit la fonction callback pour gérer les messages MQTT
  sensors.begin();                        // Initialisation du capteur de température
  pinMode(BUTTON_PIN, INPUT_PULLUP);      // Configure le bouton avec une résistance interne
}

void loop() {
  // Gestion de l'état du bouton et du contrôle de la LED
  button_state = digitalRead(BUTTON_PIN);
  if (button_state == LOW && last_button_state == HIGH) {
    led_state = !led_state;               // Inverse l'état de la LED
    if (led_state) {
      digitalWrite(BUILTIN_LED, LOW);     // Allume la LED
      client.publish("IUT/etat/led_1", "led_1_on");
      // Publie un message sur le sujet pour indiquer que la LED est allumée
    } else {
      digitalWrite(BUILTIN_LED, HIGH);    // Éteint la LED
      client.publish("IUT/etat/led_1", "led_1_off");
      // Publie un message sur le sujet pour indiquer que la LED est éteinte
    }
    delay(50);  // Anti-rebond pour le bouton
  }
  last_button_state = button_state;  // Met à jour l'état précédent du bouton

  // Reconnecte au serveur MQTT si la connexion est perdue
  if (!client.connected()) {
    reconnect();
  }
  client.loop();  // Gestion des messages MQTT

  // Publie la température toutes les 2 secondes
  unsigned long now = millis();
  if (now - lastMsg > 2000) {
    lastMsg = now;
    sensors.requestTemperatures();             // Demande la température
    float temperature = sensors.getTempCByIndex(0); // Récupère la température du premier capteur
    snprintf(msg, MSG_BUFFER_SIZE, "%.2f", temperature);  // Formatte le message
    Serial.print("Message publié: ");
    Serial.println(msg);
    client.publish("IUT/temperature", msg);    // Publie la température sur le sujet MQTT
  }
}